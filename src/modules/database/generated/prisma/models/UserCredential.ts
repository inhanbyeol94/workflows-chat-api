/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck
/**
 * This file exports the `UserCredential` model and its related types.
 *
 * üü¢ You can import this file directly.
 */
import * as runtime from '@prisma/client/runtime/library';
import type * as $Enums from '../enums';
import type * as Prisma from '../internal/prismaNamespace';

/**
 * Model UserCredential
 * ÏÇ¨Ïö©Ïûê Ïù∏Ï¶ùÏ†ïÎ≥¥
 */
export type UserCredentialModel = runtime.Types.Result.DefaultSelection<Prisma.$UserCredentialPayload>;

export type AggregateUserCredential = {
    _count: UserCredentialCountAggregateOutputType | null;
    _avg: UserCredentialAvgAggregateOutputType | null;
    _sum: UserCredentialSumAggregateOutputType | null;
    _min: UserCredentialMinAggregateOutputType | null;
    _max: UserCredentialMaxAggregateOutputType | null;
};

export type UserCredentialAvgAggregateOutputType = {
    id: number | null;
};

export type UserCredentialSumAggregateOutputType = {
    id: number | null;
};

export type UserCredentialMinAggregateOutputType = {
    id: number | null;
    loginId: string | null;
    password: string | null;
    pepper: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
};

export type UserCredentialMaxAggregateOutputType = {
    id: number | null;
    loginId: string | null;
    password: string | null;
    pepper: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
};

export type UserCredentialCountAggregateOutputType = {
    id: number;
    loginId: number;
    password: number;
    pepper: number;
    createdAt: number;
    updatedAt: number;
    deletedAt: number;
    _all: number;
};

export type UserCredentialAvgAggregateInputType = {
    id?: true;
};

export type UserCredentialSumAggregateInputType = {
    id?: true;
};

export type UserCredentialMinAggregateInputType = {
    id?: true;
    loginId?: true;
    password?: true;
    pepper?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
};

export type UserCredentialMaxAggregateInputType = {
    id?: true;
    loginId?: true;
    password?: true;
    pepper?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
};

export type UserCredentialCountAggregateInputType = {
    id?: true;
    loginId?: true;
    password?: true;
    pepper?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    _all?: true;
};

export type UserCredentialAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which UserCredential to aggregate.
     */
    where?: Prisma.UserCredentialWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserCredentials to fetch.
     */
    orderBy?: Prisma.UserCredentialOrderByWithRelationInput | Prisma.UserCredentialOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: Prisma.UserCredentialWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` UserCredentials from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserCredentials.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserCredentials
     **/
    _count?: true | UserCredentialCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UserCredentialAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UserCredentialSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserCredentialMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserCredentialMaxAggregateInputType;
};

export type GetUserCredentialAggregateType<T extends UserCredentialAggregateArgs> = {
    [P in keyof T & keyof AggregateUserCredential]: P extends '_count' | 'count'
        ? T[P] extends true
            ? number
            : Prisma.GetScalarType<T[P], AggregateUserCredential[P]>
        : Prisma.GetScalarType<T[P], AggregateUserCredential[P]>;
};

export type UserCredentialGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: Prisma.UserCredentialWhereInput;
    orderBy?: Prisma.UserCredentialOrderByWithAggregationInput | Prisma.UserCredentialOrderByWithAggregationInput[];
    by: Prisma.UserCredentialScalarFieldEnum[] | Prisma.UserCredentialScalarFieldEnum;
    having?: Prisma.UserCredentialScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCredentialCountAggregateInputType | true;
    _avg?: UserCredentialAvgAggregateInputType;
    _sum?: UserCredentialSumAggregateInputType;
    _min?: UserCredentialMinAggregateInputType;
    _max?: UserCredentialMaxAggregateInputType;
};

export type UserCredentialGroupByOutputType = {
    id: number;
    loginId: string;
    password: string;
    pepper: string;
    createdAt: Date;
    updatedAt: Date | null;
    deletedAt: Date | null;
    _count: UserCredentialCountAggregateOutputType | null;
    _avg: UserCredentialAvgAggregateOutputType | null;
    _sum: UserCredentialSumAggregateOutputType | null;
    _min: UserCredentialMinAggregateOutputType | null;
    _max: UserCredentialMaxAggregateOutputType | null;
};

type GetUserCredentialGroupByPayload<T extends UserCredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
        Prisma.PickEnumerable<UserCredentialGroupByOutputType, T['by']> & {
            [P in keyof T & keyof UserCredentialGroupByOutputType]: P extends '_count'
                ? T[P] extends boolean
                    ? number
                    : Prisma.GetScalarType<T[P], UserCredentialGroupByOutputType[P]>
                : Prisma.GetScalarType<T[P], UserCredentialGroupByOutputType[P]>;
        }
    >
>;

export type UserCredentialWhereInput = {
    AND?: Prisma.UserCredentialWhereInput | Prisma.UserCredentialWhereInput[];
    OR?: Prisma.UserCredentialWhereInput[];
    NOT?: Prisma.UserCredentialWhereInput | Prisma.UserCredentialWhereInput[];
    id?: Prisma.IntFilter<'UserCredential'> | number;
    loginId?: Prisma.StringFilter<'UserCredential'> | string;
    password?: Prisma.StringFilter<'UserCredential'> | string;
    pepper?: Prisma.StringFilter<'UserCredential'> | string;
    createdAt?: Prisma.DateTimeFilter<'UserCredential'> | Date | string;
    updatedAt?: Prisma.DateTimeNullableFilter<'UserCredential'> | Date | string | null;
    deletedAt?: Prisma.DateTimeNullableFilter<'UserCredential'> | Date | string | null;
    user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>;
};

export type UserCredentialOrderByWithRelationInput = {
    id?: Prisma.SortOrder;
    loginId?: Prisma.SortOrder;
    password?: Prisma.SortOrder;
    pepper?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
    deletedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
    user?: Prisma.UserOrderByWithRelationInput;
};

export type UserCredentialWhereUniqueInput = Prisma.AtLeast<
    {
        id?: number;
        AND?: Prisma.UserCredentialWhereInput | Prisma.UserCredentialWhereInput[];
        OR?: Prisma.UserCredentialWhereInput[];
        NOT?: Prisma.UserCredentialWhereInput | Prisma.UserCredentialWhereInput[];
        loginId?: Prisma.StringFilter<'UserCredential'> | string;
        password?: Prisma.StringFilter<'UserCredential'> | string;
        pepper?: Prisma.StringFilter<'UserCredential'> | string;
        createdAt?: Prisma.DateTimeFilter<'UserCredential'> | Date | string;
        updatedAt?: Prisma.DateTimeNullableFilter<'UserCredential'> | Date | string | null;
        deletedAt?: Prisma.DateTimeNullableFilter<'UserCredential'> | Date | string | null;
        user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>;
    },
    'id'
>;

export type UserCredentialOrderByWithAggregationInput = {
    id?: Prisma.SortOrder;
    loginId?: Prisma.SortOrder;
    password?: Prisma.SortOrder;
    pepper?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
    deletedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
    _count?: Prisma.UserCredentialCountOrderByAggregateInput;
    _avg?: Prisma.UserCredentialAvgOrderByAggregateInput;
    _max?: Prisma.UserCredentialMaxOrderByAggregateInput;
    _min?: Prisma.UserCredentialMinOrderByAggregateInput;
    _sum?: Prisma.UserCredentialSumOrderByAggregateInput;
};

export type UserCredentialScalarWhereWithAggregatesInput = {
    AND?: Prisma.UserCredentialScalarWhereWithAggregatesInput | Prisma.UserCredentialScalarWhereWithAggregatesInput[];
    OR?: Prisma.UserCredentialScalarWhereWithAggregatesInput[];
    NOT?: Prisma.UserCredentialScalarWhereWithAggregatesInput | Prisma.UserCredentialScalarWhereWithAggregatesInput[];
    id?: Prisma.IntWithAggregatesFilter<'UserCredential'> | number;
    loginId?: Prisma.StringWithAggregatesFilter<'UserCredential'> | string;
    password?: Prisma.StringWithAggregatesFilter<'UserCredential'> | string;
    pepper?: Prisma.StringWithAggregatesFilter<'UserCredential'> | string;
    createdAt?: Prisma.DateTimeWithAggregatesFilter<'UserCredential'> | Date | string;
    updatedAt?: Prisma.DateTimeNullableWithAggregatesFilter<'UserCredential'> | Date | string | null;
    deletedAt?: Prisma.DateTimeNullableWithAggregatesFilter<'UserCredential'> | Date | string | null;
};

export type UserCredentialCreateInput = {
    loginId: string;
    password: string;
    pepper: string;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
    user: Prisma.UserCreateNestedOneWithoutCredentialInput;
};

export type UserCredentialUncheckedCreateInput = {
    id: number;
    loginId: string;
    password: string;
    pepper: string;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
};

export type UserCredentialUpdateInput = {
    loginId?: Prisma.StringFieldUpdateOperationsInput | string;
    password?: Prisma.StringFieldUpdateOperationsInput | string;
    pepper?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    user?: Prisma.UserUpdateOneRequiredWithoutCredentialNestedInput;
};

export type UserCredentialUncheckedUpdateInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number;
    loginId?: Prisma.StringFieldUpdateOperationsInput | string;
    password?: Prisma.StringFieldUpdateOperationsInput | string;
    pepper?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
};

export type UserCredentialCreateManyInput = {
    id: number;
    loginId: string;
    password: string;
    pepper: string;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
};

export type UserCredentialUpdateManyMutationInput = {
    loginId?: Prisma.StringFieldUpdateOperationsInput | string;
    password?: Prisma.StringFieldUpdateOperationsInput | string;
    pepper?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
};

export type UserCredentialUncheckedUpdateManyInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number;
    loginId?: Prisma.StringFieldUpdateOperationsInput | string;
    password?: Prisma.StringFieldUpdateOperationsInput | string;
    pepper?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
};

export type UserCredentialCountOrderByAggregateInput = {
    id?: Prisma.SortOrder;
    loginId?: Prisma.SortOrder;
    password?: Prisma.SortOrder;
    pepper?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
    deletedAt?: Prisma.SortOrder;
};

export type UserCredentialAvgOrderByAggregateInput = {
    id?: Prisma.SortOrder;
};

export type UserCredentialMaxOrderByAggregateInput = {
    id?: Prisma.SortOrder;
    loginId?: Prisma.SortOrder;
    password?: Prisma.SortOrder;
    pepper?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
    deletedAt?: Prisma.SortOrder;
};

export type UserCredentialMinOrderByAggregateInput = {
    id?: Prisma.SortOrder;
    loginId?: Prisma.SortOrder;
    password?: Prisma.SortOrder;
    pepper?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
    deletedAt?: Prisma.SortOrder;
};

export type UserCredentialSumOrderByAggregateInput = {
    id?: Prisma.SortOrder;
};

export type UserCredentialNullableScalarRelationFilter = {
    is?: Prisma.UserCredentialWhereInput | null;
    isNot?: Prisma.UserCredentialWhereInput | null;
};

export type UserCredentialCreateNestedOneWithoutUserInput = {
    create?: Prisma.XOR<Prisma.UserCredentialCreateWithoutUserInput, Prisma.UserCredentialUncheckedCreateWithoutUserInput>;
    connectOrCreate?: Prisma.UserCredentialCreateOrConnectWithoutUserInput;
    connect?: Prisma.UserCredentialWhereUniqueInput;
};

export type UserCredentialUncheckedCreateNestedOneWithoutUserInput = {
    create?: Prisma.XOR<Prisma.UserCredentialCreateWithoutUserInput, Prisma.UserCredentialUncheckedCreateWithoutUserInput>;
    connectOrCreate?: Prisma.UserCredentialCreateOrConnectWithoutUserInput;
    connect?: Prisma.UserCredentialWhereUniqueInput;
};

export type UserCredentialUpdateOneWithoutUserNestedInput = {
    create?: Prisma.XOR<Prisma.UserCredentialCreateWithoutUserInput, Prisma.UserCredentialUncheckedCreateWithoutUserInput>;
    connectOrCreate?: Prisma.UserCredentialCreateOrConnectWithoutUserInput;
    upsert?: Prisma.UserCredentialUpsertWithoutUserInput;
    disconnect?: Prisma.UserCredentialWhereInput | boolean;
    delete?: Prisma.UserCredentialWhereInput | boolean;
    connect?: Prisma.UserCredentialWhereUniqueInput;
    update?: Prisma.XOR<
        Prisma.XOR<Prisma.UserCredentialUpdateToOneWithWhereWithoutUserInput, Prisma.UserCredentialUpdateWithoutUserInput>,
        Prisma.UserCredentialUncheckedUpdateWithoutUserInput
    >;
};

export type UserCredentialUncheckedUpdateOneWithoutUserNestedInput = {
    create?: Prisma.XOR<Prisma.UserCredentialCreateWithoutUserInput, Prisma.UserCredentialUncheckedCreateWithoutUserInput>;
    connectOrCreate?: Prisma.UserCredentialCreateOrConnectWithoutUserInput;
    upsert?: Prisma.UserCredentialUpsertWithoutUserInput;
    disconnect?: Prisma.UserCredentialWhereInput | boolean;
    delete?: Prisma.UserCredentialWhereInput | boolean;
    connect?: Prisma.UserCredentialWhereUniqueInput;
    update?: Prisma.XOR<
        Prisma.XOR<Prisma.UserCredentialUpdateToOneWithWhereWithoutUserInput, Prisma.UserCredentialUpdateWithoutUserInput>,
        Prisma.UserCredentialUncheckedUpdateWithoutUserInput
    >;
};

export type UserCredentialCreateWithoutUserInput = {
    loginId: string;
    password: string;
    pepper: string;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
};

export type UserCredentialUncheckedCreateWithoutUserInput = {
    loginId: string;
    password: string;
    pepper: string;
    createdAt?: Date | string;
    updatedAt?: Date | string | null;
    deletedAt?: Date | string | null;
};

export type UserCredentialCreateOrConnectWithoutUserInput = {
    where: Prisma.UserCredentialWhereUniqueInput;
    create: Prisma.XOR<Prisma.UserCredentialCreateWithoutUserInput, Prisma.UserCredentialUncheckedCreateWithoutUserInput>;
};

export type UserCredentialUpsertWithoutUserInput = {
    update: Prisma.XOR<Prisma.UserCredentialUpdateWithoutUserInput, Prisma.UserCredentialUncheckedUpdateWithoutUserInput>;
    create: Prisma.XOR<Prisma.UserCredentialCreateWithoutUserInput, Prisma.UserCredentialUncheckedCreateWithoutUserInput>;
    where?: Prisma.UserCredentialWhereInput;
};

export type UserCredentialUpdateToOneWithWhereWithoutUserInput = {
    where?: Prisma.UserCredentialWhereInput;
    data: Prisma.XOR<Prisma.UserCredentialUpdateWithoutUserInput, Prisma.UserCredentialUncheckedUpdateWithoutUserInput>;
};

export type UserCredentialUpdateWithoutUserInput = {
    loginId?: Prisma.StringFieldUpdateOperationsInput | string;
    password?: Prisma.StringFieldUpdateOperationsInput | string;
    pepper?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
};

export type UserCredentialUncheckedUpdateWithoutUserInput = {
    loginId?: Prisma.StringFieldUpdateOperationsInput | string;
    password?: Prisma.StringFieldUpdateOperationsInput | string;
    pepper?: Prisma.StringFieldUpdateOperationsInput | string;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deletedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
};

export type UserCredentialSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
    runtime.Types.Extensions.GetSelect<
        {
            id?: boolean;
            loginId?: boolean;
            password?: boolean;
            pepper?: boolean;
            createdAt?: boolean;
            updatedAt?: boolean;
            deletedAt?: boolean;
            user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
        },
        ExtArgs['result']['userCredential']
    >;

export type UserCredentialSelectCreateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
    {
        id?: boolean;
        loginId?: boolean;
        password?: boolean;
        pepper?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        deletedAt?: boolean;
        user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userCredential']
>;

export type UserCredentialSelectUpdateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
    {
        id?: boolean;
        loginId?: boolean;
        password?: boolean;
        pepper?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        deletedAt?: boolean;
        user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userCredential']
>;

export type UserCredentialSelectScalar = {
    id?: boolean;
    loginId?: boolean;
    password?: boolean;
    pepper?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deletedAt?: boolean;
};

export type UserCredentialOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
    runtime.Types.Extensions.GetOmit<
        'id' | 'loginId' | 'password' | 'pepper' | 'createdAt' | 'updatedAt' | 'deletedAt',
        ExtArgs['result']['userCredential']
    >;
export type UserCredentialInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};
export type UserCredentialIncludeCreateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};
export type UserCredentialIncludeUpdateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};

export type $UserCredentialPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: 'UserCredential';
    objects: {
        /**
         * ÏÇ¨Ïö©Ïûê
         */
        user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<
        {
            /**
             * ÏïÑÏù¥Îîî
             */
            id: number;
            /**
             * Î°úÍ∑∏Ïù∏ ÏïÑÏù¥Îîî
             */
            loginId: string;
            /**
             * Ìå®Ïä§ÏõåÎìú
             */
            password: string;
            /**
             * Ìå®Ïä§ÏõåÎìú Ï°∞Ìï© Í∞í
             */
            pepper: string;
            /**
             * ÏÉùÏÑ±Ïùº
             */
            createdAt: Date;
            /**
             * ÏàòÏ†ïÏùº
             */
            updatedAt: Date | null;
            /**
             * ÏÇ≠Ï†úÏùº
             */
            deletedAt: Date | null;
        },
        ExtArgs['result']['userCredential']
    >;
    composites: {};
};

export type UserCredentialGetPayload<S extends boolean | null | undefined | UserCredentialDefaultArgs> = runtime.Types.Result.GetResult<
    Prisma.$UserCredentialPayload,
    S
>;

export type UserCredentialCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<
    UserCredentialFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
> & {
    select?: UserCredentialCountAggregateInputType | true;
};

export interface UserCredentialDelegate<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
    GlobalOmitOptions = {},
> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCredential']; meta: { name: 'UserCredential' } };
    /**
     * Find zero or one UserCredential that matches the filter.
     * @param {UserCredentialFindUniqueArgs} args - Arguments to find a UserCredential
     * @example
     * // Get one UserCredential
     * const userCredential = await prisma.userCredential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCredentialFindUniqueArgs>(
        args: Prisma.SelectSubset<T, UserCredentialFindUniqueArgs<ExtArgs>>,
    ): Prisma.Prisma__UserCredentialClient<
        runtime.Types.Result.GetResult<Prisma.$UserCredentialPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
        null,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find one UserCredential that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCredentialFindUniqueOrThrowArgs} args - Arguments to find a UserCredential
     * @example
     * // Get one UserCredential
     * const userCredential = await prisma.userCredential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCredentialFindUniqueOrThrowArgs>(
        args: Prisma.SelectSubset<T, UserCredentialFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma.Prisma__UserCredentialClient<
        runtime.Types.Result.GetResult<Prisma.$UserCredentialPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find the first UserCredential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCredentialFindFirstArgs} args - Arguments to find a UserCredential
     * @example
     * // Get one UserCredential
     * const userCredential = await prisma.userCredential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCredentialFindFirstArgs>(
        args?: Prisma.SelectSubset<T, UserCredentialFindFirstArgs<ExtArgs>>,
    ): Prisma.Prisma__UserCredentialClient<
        runtime.Types.Result.GetResult<Prisma.$UserCredentialPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
        null,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find the first UserCredential that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCredentialFindFirstOrThrowArgs} args - Arguments to find a UserCredential
     * @example
     * // Get one UserCredential
     * const userCredential = await prisma.userCredential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCredentialFindFirstOrThrowArgs>(
        args?: Prisma.SelectSubset<T, UserCredentialFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma.Prisma__UserCredentialClient<
        runtime.Types.Result.GetResult<Prisma.$UserCredentialPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find zero or more UserCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCredentialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCredentials
     * const userCredentials = await prisma.userCredential.findMany()
     *
     * // Get first 10 UserCredentials
     * const userCredentials = await prisma.userCredential.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userCredentialWithIdOnly = await prisma.userCredential.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserCredentialFindManyArgs>(
        args?: Prisma.SelectSubset<T, UserCredentialFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$UserCredentialPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>;

    /**
     * Create a UserCredential.
     * @param {UserCredentialCreateArgs} args - Arguments to create a UserCredential.
     * @example
     * // Create one UserCredential
     * const UserCredential = await prisma.userCredential.create({
     *   data: {
     *     // ... data to create a UserCredential
     *   }
     * })
     *
     */
    create<T extends UserCredentialCreateArgs>(
        args: Prisma.SelectSubset<T, UserCredentialCreateArgs<ExtArgs>>,
    ): Prisma.Prisma__UserCredentialClient<
        runtime.Types.Result.GetResult<Prisma.$UserCredentialPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Create many UserCredentials.
     * @param {UserCredentialCreateManyArgs} args - Arguments to create many UserCredentials.
     * @example
     * // Create many UserCredentials
     * const userCredential = await prisma.userCredential.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCredentialCreateManyArgs>(
        args?: Prisma.SelectSubset<T, UserCredentialCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Create many UserCredentials and returns the data saved in the modules.database.
     * @param {UserCredentialCreateManyAndReturnArgs} args - Arguments to create many UserCredentials.
     * @example
     * // Create many UserCredentials
     * const userCredential = await prisma.userCredential.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserCredentials and only return the `id`
     * const userCredentialWithIdOnly = await prisma.userCredential.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCredentialCreateManyAndReturnArgs>(
        args?: Prisma.SelectSubset<T, UserCredentialCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<Prisma.$UserCredentialPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Delete a UserCredential.
     * @param {UserCredentialDeleteArgs} args - Arguments to delete one UserCredential.
     * @example
     * // Delete one UserCredential
     * const UserCredential = await prisma.userCredential.delete({
     *   where: {
     *     // ... filter to delete one UserCredential
     *   }
     * })
     *
     */
    delete<T extends UserCredentialDeleteArgs>(
        args: Prisma.SelectSubset<T, UserCredentialDeleteArgs<ExtArgs>>,
    ): Prisma.Prisma__UserCredentialClient<
        runtime.Types.Result.GetResult<Prisma.$UserCredentialPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Update one UserCredential.
     * @param {UserCredentialUpdateArgs} args - Arguments to update one UserCredential.
     * @example
     * // Update one UserCredential
     * const userCredential = await prisma.userCredential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserCredentialUpdateArgs>(
        args: Prisma.SelectSubset<T, UserCredentialUpdateArgs<ExtArgs>>,
    ): Prisma.Prisma__UserCredentialClient<
        runtime.Types.Result.GetResult<Prisma.$UserCredentialPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserCredentials.
     * @param {UserCredentialDeleteManyArgs} args - Arguments to filter UserCredentials to delete.
     * @example
     * // Delete a few UserCredentials
     * const { count } = await prisma.userCredential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserCredentialDeleteManyArgs>(
        args?: Prisma.SelectSubset<T, UserCredentialDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Update zero or more UserCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCredentials
     * const userCredential = await prisma.userCredential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserCredentialUpdateManyArgs>(
        args: Prisma.SelectSubset<T, UserCredentialUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Update zero or more UserCredentials and returns the data updated in the modules.database.
     * @param {UserCredentialUpdateManyAndReturnArgs} args - Arguments to update many UserCredentials.
     * @example
     * // Update many UserCredentials
     * const userCredential = await prisma.userCredential.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserCredentials and only return the `id`
     * const userCredentialWithIdOnly = await prisma.userCredential.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserCredentialUpdateManyAndReturnArgs>(
        args: Prisma.SelectSubset<T, UserCredentialUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<Prisma.$UserCredentialPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Create or update one UserCredential.
     * @param {UserCredentialUpsertArgs} args - Arguments to update or create a UserCredential.
     * @example
     * // Update or create a UserCredential
     * const userCredential = await prisma.userCredential.upsert({
     *   create: {
     *     // ... data to create a UserCredential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCredential we want to update
     *   }
     * })
     */
    upsert<T extends UserCredentialUpsertArgs>(
        args: Prisma.SelectSubset<T, UserCredentialUpsertArgs<ExtArgs>>,
    ): Prisma.Prisma__UserCredentialClient<
        runtime.Types.Result.GetResult<Prisma.$UserCredentialPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Count the number of UserCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCredentialCountArgs} args - Arguments to filter UserCredentials to count.
     * @example
     * // Count the number of UserCredentials
     * const count = await prisma.userCredential.count({
     *   where: {
     *     // ... the filter for the UserCredentials we want to count
     *   }
     * })
     **/
    count<T extends UserCredentialCountArgs>(
        args?: Prisma.Subset<T, UserCredentialCountArgs>,
    ): Prisma.PrismaPromise<
        T extends runtime.Types.Utils.Record<'select', any>
            ? T['select'] extends true
                ? number
                : Prisma.GetScalarType<T['select'], UserCredentialCountAggregateOutputType>
            : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.modules.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserCredentialAggregateArgs>(
        args: Prisma.Subset<T, UserCredentialAggregateArgs>,
    ): Prisma.PrismaPromise<GetUserCredentialAggregateType<T>>;

    /**
     * Group by UserCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.modules.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
        T extends UserCredentialGroupByArgs,
        HasSelectOrTake extends Prisma.Or<Prisma.Extends<'skip', Prisma.Keys<T>>, Prisma.Extends<'take', Prisma.Keys<T>>>,
        OrderByArg extends Prisma.True extends HasSelectOrTake
            ? { orderBy: UserCredentialGroupByArgs['orderBy'] }
            : { orderBy?: UserCredentialGroupByArgs['orderBy'] },
        OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
        ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
        ByValid extends Prisma.Has<ByFields, OrderFields>,
        HavingFields extends Prisma.GetHavingFields<T['having']>,
        HavingValid extends Prisma.Has<ByFields, HavingFields>,
        ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
        InputErrors extends ByEmpty extends Prisma.True
            ? `Error: "by" must not be empty.`
            : HavingValid extends Prisma.False
              ? {
                    [P in HavingFields]: P extends ByFields
                        ? never
                        : P extends string
                          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                          : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Prisma.Keys<T>
                ? 'orderBy' extends Prisma.Keys<T>
                    ? ByValid extends Prisma.True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                    : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Prisma.Keys<T>
                  ? 'orderBy' extends Prisma.Keys<T>
                      ? ByValid extends Prisma.True
                          ? {}
                          : {
                                [P in OrderFields]: P extends ByFields
                                    ? never
                                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                            }[OrderFields]
                      : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends Prisma.True
                    ? {}
                    : {
                          [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
    >(
        args: Prisma.SubsetIntersection<T, UserCredentialGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetUserCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserCredential model
     */
    readonly fields: UserCredentialFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for UserCredential.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__UserCredentialClient<
    T,
    Null = never,
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
    GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(
        args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>,
    ): Prisma.Prisma__UserClient<
        runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
        Null,
        ExtArgs,
        GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
        onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the UserCredential model
 */
export interface UserCredentialFieldRefs {
    readonly id: Prisma.FieldRef<'UserCredential', 'Int'>;
    readonly loginId: Prisma.FieldRef<'UserCredential', 'String'>;
    readonly password: Prisma.FieldRef<'UserCredential', 'String'>;
    readonly pepper: Prisma.FieldRef<'UserCredential', 'String'>;
    readonly createdAt: Prisma.FieldRef<'UserCredential', 'DateTime'>;
    readonly updatedAt: Prisma.FieldRef<'UserCredential', 'DateTime'>;
    readonly deletedAt: Prisma.FieldRef<'UserCredential', 'DateTime'>;
}

// Custom InputTypes
/**
 * UserCredential findUnique
 */
export type UserCredentialFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCredential
     */
    select?: Prisma.UserCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCredential
     */
    omit?: Prisma.UserCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.UserCredentialInclude<ExtArgs> | null;
    /**
     * Filter, which UserCredential to fetch.
     */
    where: Prisma.UserCredentialWhereUniqueInput;
};

/**
 * UserCredential findUniqueOrThrow
 */
export type UserCredentialFindUniqueOrThrowArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the UserCredential
     */
    select?: Prisma.UserCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCredential
     */
    omit?: Prisma.UserCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.UserCredentialInclude<ExtArgs> | null;
    /**
     * Filter, which UserCredential to fetch.
     */
    where: Prisma.UserCredentialWhereUniqueInput;
};

/**
 * UserCredential findFirst
 */
export type UserCredentialFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCredential
     */
    select?: Prisma.UserCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCredential
     */
    omit?: Prisma.UserCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.UserCredentialInclude<ExtArgs> | null;
    /**
     * Filter, which UserCredential to fetch.
     */
    where?: Prisma.UserCredentialWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserCredentials to fetch.
     */
    orderBy?: Prisma.UserCredentialOrderByWithRelationInput | Prisma.UserCredentialOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserCredentials.
     */
    cursor?: Prisma.UserCredentialWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` UserCredentials from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserCredentials.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserCredentials.
     */
    distinct?: Prisma.UserCredentialScalarFieldEnum | Prisma.UserCredentialScalarFieldEnum[];
};

/**
 * UserCredential findFirstOrThrow
 */
export type UserCredentialFindFirstOrThrowArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the UserCredential
     */
    select?: Prisma.UserCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCredential
     */
    omit?: Prisma.UserCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.UserCredentialInclude<ExtArgs> | null;
    /**
     * Filter, which UserCredential to fetch.
     */
    where?: Prisma.UserCredentialWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserCredentials to fetch.
     */
    orderBy?: Prisma.UserCredentialOrderByWithRelationInput | Prisma.UserCredentialOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserCredentials.
     */
    cursor?: Prisma.UserCredentialWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` UserCredentials from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserCredentials.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserCredentials.
     */
    distinct?: Prisma.UserCredentialScalarFieldEnum | Prisma.UserCredentialScalarFieldEnum[];
};

/**
 * UserCredential findMany
 */
export type UserCredentialFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCredential
     */
    select?: Prisma.UserCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCredential
     */
    omit?: Prisma.UserCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.UserCredentialInclude<ExtArgs> | null;
    /**
     * Filter, which UserCredentials to fetch.
     */
    where?: Prisma.UserCredentialWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserCredentials to fetch.
     */
    orderBy?: Prisma.UserCredentialOrderByWithRelationInput | Prisma.UserCredentialOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserCredentials.
     */
    cursor?: Prisma.UserCredentialWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` UserCredentials from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserCredentials.
     */
    skip?: number;
    distinct?: Prisma.UserCredentialScalarFieldEnum | Prisma.UserCredentialScalarFieldEnum[];
};

/**
 * UserCredential create
 */
export type UserCredentialCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCredential
     */
    select?: Prisma.UserCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCredential
     */
    omit?: Prisma.UserCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.UserCredentialInclude<ExtArgs> | null;
    /**
     * The data needed to create a UserCredential.
     */
    data: Prisma.XOR<Prisma.UserCredentialCreateInput, Prisma.UserCredentialUncheckedCreateInput>;
};

/**
 * UserCredential createMany
 */
export type UserCredentialCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCredentials.
     */
    data: Prisma.UserCredentialCreateManyInput | Prisma.UserCredentialCreateManyInput[];
    skipDuplicates?: boolean;
};

/**
 * UserCredential createManyAndReturn
 */
export type UserCredentialCreateManyAndReturnArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the UserCredential
     */
    select?: Prisma.UserCredentialSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCredential
     */
    omit?: Prisma.UserCredentialOmit<ExtArgs> | null;
    /**
     * The data used to create many UserCredentials.
     */
    data: Prisma.UserCredentialCreateManyInput | Prisma.UserCredentialCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.UserCredentialIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * UserCredential update
 */
export type UserCredentialUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCredential
     */
    select?: Prisma.UserCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCredential
     */
    omit?: Prisma.UserCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.UserCredentialInclude<ExtArgs> | null;
    /**
     * The data needed to update a UserCredential.
     */
    data: Prisma.XOR<Prisma.UserCredentialUpdateInput, Prisma.UserCredentialUncheckedUpdateInput>;
    /**
     * Choose, which UserCredential to update.
     */
    where: Prisma.UserCredentialWhereUniqueInput;
};

/**
 * UserCredential updateMany
 */
export type UserCredentialUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCredentials.
     */
    data: Prisma.XOR<Prisma.UserCredentialUpdateManyMutationInput, Prisma.UserCredentialUncheckedUpdateManyInput>;
    /**
     * Filter which UserCredentials to update
     */
    where?: Prisma.UserCredentialWhereInput;
    /**
     * Limit how many UserCredentials to update.
     */
    limit?: number;
};

/**
 * UserCredential updateManyAndReturn
 */
export type UserCredentialUpdateManyAndReturnArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the UserCredential
     */
    select?: Prisma.UserCredentialSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCredential
     */
    omit?: Prisma.UserCredentialOmit<ExtArgs> | null;
    /**
     * The data used to update UserCredentials.
     */
    data: Prisma.XOR<Prisma.UserCredentialUpdateManyMutationInput, Prisma.UserCredentialUncheckedUpdateManyInput>;
    /**
     * Filter which UserCredentials to update
     */
    where?: Prisma.UserCredentialWhereInput;
    /**
     * Limit how many UserCredentials to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.UserCredentialIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * UserCredential upsert
 */
export type UserCredentialUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCredential
     */
    select?: Prisma.UserCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCredential
     */
    omit?: Prisma.UserCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.UserCredentialInclude<ExtArgs> | null;
    /**
     * The filter to search for the UserCredential to update in case it exists.
     */
    where: Prisma.UserCredentialWhereUniqueInput;
    /**
     * In case the UserCredential found by the `where` argument doesn't exist, create a new UserCredential with this data.
     */
    create: Prisma.XOR<Prisma.UserCredentialCreateInput, Prisma.UserCredentialUncheckedCreateInput>;
    /**
     * In case the UserCredential was found with the provided `where` argument, update it with this data.
     */
    update: Prisma.XOR<Prisma.UserCredentialUpdateInput, Prisma.UserCredentialUncheckedUpdateInput>;
};

/**
 * UserCredential delete
 */
export type UserCredentialDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCredential
     */
    select?: Prisma.UserCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCredential
     */
    omit?: Prisma.UserCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.UserCredentialInclude<ExtArgs> | null;
    /**
     * Filter which UserCredential to delete.
     */
    where: Prisma.UserCredentialWhereUniqueInput;
};

/**
 * UserCredential deleteMany
 */
export type UserCredentialDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which UserCredentials to delete
     */
    where?: Prisma.UserCredentialWhereInput;
    /**
     * Limit how many UserCredentials to delete.
     */
    limit?: number;
};

/**
 * UserCredential without action
 */
export type UserCredentialDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCredential
     */
    select?: Prisma.UserCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserCredential
     */
    omit?: Prisma.UserCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.UserCredentialInclude<ExtArgs> | null;
};
