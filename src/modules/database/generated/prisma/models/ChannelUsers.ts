/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck
/**
 * This file exports the `ChannelUsers` model and its related types.
 *
 * üü¢ You can import this file directly.
 */
import * as runtime from '@prisma/client/runtime/library';
import type * as $Enums from '../enums';
import type * as Prisma from '../internal/prismaNamespace';

/**
 * Model ChannelUsers
 * Ï±ÑÎÑêÏóê ÏÜçÌïú ÏÇ¨Ïö©Ïûê (ÎπÑÎ∞ÄÏ±ÑÎÑêÏù∏ Í≤ΩÏö∞)
 */
export type ChannelUsersModel = runtime.Types.Result.DefaultSelection<Prisma.$ChannelUsersPayload>;

export type AggregateChannelUsers = {
    _count: ChannelUsersCountAggregateOutputType | null;
    _avg: ChannelUsersAvgAggregateOutputType | null;
    _sum: ChannelUsersSumAggregateOutputType | null;
    _min: ChannelUsersMinAggregateOutputType | null;
    _max: ChannelUsersMaxAggregateOutputType | null;
};

export type ChannelUsersAvgAggregateOutputType = {
    channelId: number | null;
    userId: number | null;
};

export type ChannelUsersSumAggregateOutputType = {
    channelId: number | null;
    userId: number | null;
};

export type ChannelUsersMinAggregateOutputType = {
    channelId: number | null;
    userId: number | null;
    createdAt: Date | null;
};

export type ChannelUsersMaxAggregateOutputType = {
    channelId: number | null;
    userId: number | null;
    createdAt: Date | null;
};

export type ChannelUsersCountAggregateOutputType = {
    channelId: number;
    userId: number;
    createdAt: number;
    _all: number;
};

export type ChannelUsersAvgAggregateInputType = {
    channelId?: true;
    userId?: true;
};

export type ChannelUsersSumAggregateInputType = {
    channelId?: true;
    userId?: true;
};

export type ChannelUsersMinAggregateInputType = {
    channelId?: true;
    userId?: true;
    createdAt?: true;
};

export type ChannelUsersMaxAggregateInputType = {
    channelId?: true;
    userId?: true;
    createdAt?: true;
};

export type ChannelUsersCountAggregateInputType = {
    channelId?: true;
    userId?: true;
    createdAt?: true;
    _all?: true;
};

export type ChannelUsersAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelUsers to aggregate.
     */
    where?: Prisma.ChannelUsersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ChannelUsers to fetch.
     */
    orderBy?: Prisma.ChannelUsersOrderByWithRelationInput | Prisma.ChannelUsersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: Prisma.ChannelUsersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` ChannelUsers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ChannelUsers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ChannelUsers
     **/
    _count?: true | ChannelUsersCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ChannelUsersAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ChannelUsersSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ChannelUsersMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ChannelUsersMaxAggregateInputType;
};

export type GetChannelUsersAggregateType<T extends ChannelUsersAggregateArgs> = {
    [P in keyof T & keyof AggregateChannelUsers]: P extends '_count' | 'count'
        ? T[P] extends true
            ? number
            : Prisma.GetScalarType<T[P], AggregateChannelUsers[P]>
        : Prisma.GetScalarType<T[P], AggregateChannelUsers[P]>;
};

export type ChannelUsersGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: Prisma.ChannelUsersWhereInput;
    orderBy?: Prisma.ChannelUsersOrderByWithAggregationInput | Prisma.ChannelUsersOrderByWithAggregationInput[];
    by: Prisma.ChannelUsersScalarFieldEnum[] | Prisma.ChannelUsersScalarFieldEnum;
    having?: Prisma.ChannelUsersScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ChannelUsersCountAggregateInputType | true;
    _avg?: ChannelUsersAvgAggregateInputType;
    _sum?: ChannelUsersSumAggregateInputType;
    _min?: ChannelUsersMinAggregateInputType;
    _max?: ChannelUsersMaxAggregateInputType;
};

export type ChannelUsersGroupByOutputType = {
    channelId: number;
    userId: number;
    createdAt: Date;
    _count: ChannelUsersCountAggregateOutputType | null;
    _avg: ChannelUsersAvgAggregateOutputType | null;
    _sum: ChannelUsersSumAggregateOutputType | null;
    _min: ChannelUsersMinAggregateOutputType | null;
    _max: ChannelUsersMaxAggregateOutputType | null;
};

type GetChannelUsersGroupByPayload<T extends ChannelUsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
        Prisma.PickEnumerable<ChannelUsersGroupByOutputType, T['by']> & {
            [P in keyof T & keyof ChannelUsersGroupByOutputType]: P extends '_count'
                ? T[P] extends boolean
                    ? number
                    : Prisma.GetScalarType<T[P], ChannelUsersGroupByOutputType[P]>
                : Prisma.GetScalarType<T[P], ChannelUsersGroupByOutputType[P]>;
        }
    >
>;

export type ChannelUsersWhereInput = {
    AND?: Prisma.ChannelUsersWhereInput | Prisma.ChannelUsersWhereInput[];
    OR?: Prisma.ChannelUsersWhereInput[];
    NOT?: Prisma.ChannelUsersWhereInput | Prisma.ChannelUsersWhereInput[];
    channelId?: Prisma.IntFilter<'ChannelUsers'> | number;
    userId?: Prisma.IntFilter<'ChannelUsers'> | number;
    createdAt?: Prisma.DateTimeFilter<'ChannelUsers'> | Date | string;
    channel?: Prisma.XOR<Prisma.ChannelScalarRelationFilter, Prisma.ChannelWhereInput>;
    user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>;
};

export type ChannelUsersOrderByWithRelationInput = {
    channelId?: Prisma.SortOrder;
    userId?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    channel?: Prisma.ChannelOrderByWithRelationInput;
    user?: Prisma.UserOrderByWithRelationInput;
};

export type ChannelUsersWhereUniqueInput = Prisma.AtLeast<
    {
        channelId_userId?: Prisma.ChannelUsersChannelIdUserIdCompoundUniqueInput;
        AND?: Prisma.ChannelUsersWhereInput | Prisma.ChannelUsersWhereInput[];
        OR?: Prisma.ChannelUsersWhereInput[];
        NOT?: Prisma.ChannelUsersWhereInput | Prisma.ChannelUsersWhereInput[];
        channelId?: Prisma.IntFilter<'ChannelUsers'> | number;
        userId?: Prisma.IntFilter<'ChannelUsers'> | number;
        createdAt?: Prisma.DateTimeFilter<'ChannelUsers'> | Date | string;
        channel?: Prisma.XOR<Prisma.ChannelScalarRelationFilter, Prisma.ChannelWhereInput>;
        user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>;
    },
    'channelId_userId'
>;

export type ChannelUsersOrderByWithAggregationInput = {
    channelId?: Prisma.SortOrder;
    userId?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    _count?: Prisma.ChannelUsersCountOrderByAggregateInput;
    _avg?: Prisma.ChannelUsersAvgOrderByAggregateInput;
    _max?: Prisma.ChannelUsersMaxOrderByAggregateInput;
    _min?: Prisma.ChannelUsersMinOrderByAggregateInput;
    _sum?: Prisma.ChannelUsersSumOrderByAggregateInput;
};

export type ChannelUsersScalarWhereWithAggregatesInput = {
    AND?: Prisma.ChannelUsersScalarWhereWithAggregatesInput | Prisma.ChannelUsersScalarWhereWithAggregatesInput[];
    OR?: Prisma.ChannelUsersScalarWhereWithAggregatesInput[];
    NOT?: Prisma.ChannelUsersScalarWhereWithAggregatesInput | Prisma.ChannelUsersScalarWhereWithAggregatesInput[];
    channelId?: Prisma.IntWithAggregatesFilter<'ChannelUsers'> | number;
    userId?: Prisma.IntWithAggregatesFilter<'ChannelUsers'> | number;
    createdAt?: Prisma.DateTimeWithAggregatesFilter<'ChannelUsers'> | Date | string;
};

export type ChannelUsersCreateInput = {
    createdAt?: Date | string;
    channel: Prisma.ChannelCreateNestedOneWithoutUsersInput;
    user: Prisma.UserCreateNestedOneWithoutChannelsInput;
};

export type ChannelUsersUncheckedCreateInput = {
    channelId: number;
    userId: number;
    createdAt?: Date | string;
};

export type ChannelUsersUpdateInput = {
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    channel?: Prisma.ChannelUpdateOneRequiredWithoutUsersNestedInput;
    user?: Prisma.UserUpdateOneRequiredWithoutChannelsNestedInput;
};

export type ChannelUsersUncheckedUpdateInput = {
    channelId?: Prisma.IntFieldUpdateOperationsInput | number;
    userId?: Prisma.IntFieldUpdateOperationsInput | number;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ChannelUsersCreateManyInput = {
    channelId: number;
    userId: number;
    createdAt?: Date | string;
};

export type ChannelUsersUpdateManyMutationInput = {
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ChannelUsersUncheckedUpdateManyInput = {
    channelId?: Prisma.IntFieldUpdateOperationsInput | number;
    userId?: Prisma.IntFieldUpdateOperationsInput | number;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ChannelUsersChannelIdUserIdCompoundUniqueInput = {
    channelId: number;
    userId: number;
};

export type ChannelUsersCountOrderByAggregateInput = {
    channelId?: Prisma.SortOrder;
    userId?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
};

export type ChannelUsersAvgOrderByAggregateInput = {
    channelId?: Prisma.SortOrder;
    userId?: Prisma.SortOrder;
};

export type ChannelUsersMaxOrderByAggregateInput = {
    channelId?: Prisma.SortOrder;
    userId?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
};

export type ChannelUsersMinOrderByAggregateInput = {
    channelId?: Prisma.SortOrder;
    userId?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
};

export type ChannelUsersSumOrderByAggregateInput = {
    channelId?: Prisma.SortOrder;
    userId?: Prisma.SortOrder;
};

export type ChannelUsersListRelationFilter = {
    every?: Prisma.ChannelUsersWhereInput;
    some?: Prisma.ChannelUsersWhereInput;
    none?: Prisma.ChannelUsersWhereInput;
};

export type ChannelUsersOrderByRelationAggregateInput = {
    _count?: Prisma.SortOrder;
};

export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
};

export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
};

export type ChannelUsersCreateNestedManyWithoutChannelInput = {
    create?:
        | Prisma.XOR<Prisma.ChannelUsersCreateWithoutChannelInput, Prisma.ChannelUsersUncheckedCreateWithoutChannelInput>
        | Prisma.ChannelUsersCreateWithoutChannelInput[]
        | Prisma.ChannelUsersUncheckedCreateWithoutChannelInput[];
    connectOrCreate?: Prisma.ChannelUsersCreateOrConnectWithoutChannelInput | Prisma.ChannelUsersCreateOrConnectWithoutChannelInput[];
    createMany?: Prisma.ChannelUsersCreateManyChannelInputEnvelope;
    connect?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
};

export type ChannelUsersUncheckedCreateNestedManyWithoutChannelInput = {
    create?:
        | Prisma.XOR<Prisma.ChannelUsersCreateWithoutChannelInput, Prisma.ChannelUsersUncheckedCreateWithoutChannelInput>
        | Prisma.ChannelUsersCreateWithoutChannelInput[]
        | Prisma.ChannelUsersUncheckedCreateWithoutChannelInput[];
    connectOrCreate?: Prisma.ChannelUsersCreateOrConnectWithoutChannelInput | Prisma.ChannelUsersCreateOrConnectWithoutChannelInput[];
    createMany?: Prisma.ChannelUsersCreateManyChannelInputEnvelope;
    connect?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
};

export type ChannelUsersUpdateManyWithoutChannelNestedInput = {
    create?:
        | Prisma.XOR<Prisma.ChannelUsersCreateWithoutChannelInput, Prisma.ChannelUsersUncheckedCreateWithoutChannelInput>
        | Prisma.ChannelUsersCreateWithoutChannelInput[]
        | Prisma.ChannelUsersUncheckedCreateWithoutChannelInput[];
    connectOrCreate?: Prisma.ChannelUsersCreateOrConnectWithoutChannelInput | Prisma.ChannelUsersCreateOrConnectWithoutChannelInput[];
    upsert?: Prisma.ChannelUsersUpsertWithWhereUniqueWithoutChannelInput | Prisma.ChannelUsersUpsertWithWhereUniqueWithoutChannelInput[];
    createMany?: Prisma.ChannelUsersCreateManyChannelInputEnvelope;
    set?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
    disconnect?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
    delete?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
    connect?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
    update?: Prisma.ChannelUsersUpdateWithWhereUniqueWithoutChannelInput | Prisma.ChannelUsersUpdateWithWhereUniqueWithoutChannelInput[];
    updateMany?: Prisma.ChannelUsersUpdateManyWithWhereWithoutChannelInput | Prisma.ChannelUsersUpdateManyWithWhereWithoutChannelInput[];
    deleteMany?: Prisma.ChannelUsersScalarWhereInput | Prisma.ChannelUsersScalarWhereInput[];
};

export type ChannelUsersUncheckedUpdateManyWithoutChannelNestedInput = {
    create?:
        | Prisma.XOR<Prisma.ChannelUsersCreateWithoutChannelInput, Prisma.ChannelUsersUncheckedCreateWithoutChannelInput>
        | Prisma.ChannelUsersCreateWithoutChannelInput[]
        | Prisma.ChannelUsersUncheckedCreateWithoutChannelInput[];
    connectOrCreate?: Prisma.ChannelUsersCreateOrConnectWithoutChannelInput | Prisma.ChannelUsersCreateOrConnectWithoutChannelInput[];
    upsert?: Prisma.ChannelUsersUpsertWithWhereUniqueWithoutChannelInput | Prisma.ChannelUsersUpsertWithWhereUniqueWithoutChannelInput[];
    createMany?: Prisma.ChannelUsersCreateManyChannelInputEnvelope;
    set?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
    disconnect?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
    delete?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
    connect?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
    update?: Prisma.ChannelUsersUpdateWithWhereUniqueWithoutChannelInput | Prisma.ChannelUsersUpdateWithWhereUniqueWithoutChannelInput[];
    updateMany?: Prisma.ChannelUsersUpdateManyWithWhereWithoutChannelInput | Prisma.ChannelUsersUpdateManyWithWhereWithoutChannelInput[];
    deleteMany?: Prisma.ChannelUsersScalarWhereInput | Prisma.ChannelUsersScalarWhereInput[];
};

export type ChannelUsersCreateNestedManyWithoutUserInput = {
    create?:
        | Prisma.XOR<Prisma.ChannelUsersCreateWithoutUserInput, Prisma.ChannelUsersUncheckedCreateWithoutUserInput>
        | Prisma.ChannelUsersCreateWithoutUserInput[]
        | Prisma.ChannelUsersUncheckedCreateWithoutUserInput[];
    connectOrCreate?: Prisma.ChannelUsersCreateOrConnectWithoutUserInput | Prisma.ChannelUsersCreateOrConnectWithoutUserInput[];
    createMany?: Prisma.ChannelUsersCreateManyUserInputEnvelope;
    connect?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
};

export type ChannelUsersUncheckedCreateNestedManyWithoutUserInput = {
    create?:
        | Prisma.XOR<Prisma.ChannelUsersCreateWithoutUserInput, Prisma.ChannelUsersUncheckedCreateWithoutUserInput>
        | Prisma.ChannelUsersCreateWithoutUserInput[]
        | Prisma.ChannelUsersUncheckedCreateWithoutUserInput[];
    connectOrCreate?: Prisma.ChannelUsersCreateOrConnectWithoutUserInput | Prisma.ChannelUsersCreateOrConnectWithoutUserInput[];
    createMany?: Prisma.ChannelUsersCreateManyUserInputEnvelope;
    connect?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
};

export type ChannelUsersUpdateManyWithoutUserNestedInput = {
    create?:
        | Prisma.XOR<Prisma.ChannelUsersCreateWithoutUserInput, Prisma.ChannelUsersUncheckedCreateWithoutUserInput>
        | Prisma.ChannelUsersCreateWithoutUserInput[]
        | Prisma.ChannelUsersUncheckedCreateWithoutUserInput[];
    connectOrCreate?: Prisma.ChannelUsersCreateOrConnectWithoutUserInput | Prisma.ChannelUsersCreateOrConnectWithoutUserInput[];
    upsert?: Prisma.ChannelUsersUpsertWithWhereUniqueWithoutUserInput | Prisma.ChannelUsersUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: Prisma.ChannelUsersCreateManyUserInputEnvelope;
    set?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
    disconnect?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
    delete?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
    connect?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
    update?: Prisma.ChannelUsersUpdateWithWhereUniqueWithoutUserInput | Prisma.ChannelUsersUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: Prisma.ChannelUsersUpdateManyWithWhereWithoutUserInput | Prisma.ChannelUsersUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: Prisma.ChannelUsersScalarWhereInput | Prisma.ChannelUsersScalarWhereInput[];
};

export type ChannelUsersUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
        | Prisma.XOR<Prisma.ChannelUsersCreateWithoutUserInput, Prisma.ChannelUsersUncheckedCreateWithoutUserInput>
        | Prisma.ChannelUsersCreateWithoutUserInput[]
        | Prisma.ChannelUsersUncheckedCreateWithoutUserInput[];
    connectOrCreate?: Prisma.ChannelUsersCreateOrConnectWithoutUserInput | Prisma.ChannelUsersCreateOrConnectWithoutUserInput[];
    upsert?: Prisma.ChannelUsersUpsertWithWhereUniqueWithoutUserInput | Prisma.ChannelUsersUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: Prisma.ChannelUsersCreateManyUserInputEnvelope;
    set?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
    disconnect?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
    delete?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
    connect?: Prisma.ChannelUsersWhereUniqueInput | Prisma.ChannelUsersWhereUniqueInput[];
    update?: Prisma.ChannelUsersUpdateWithWhereUniqueWithoutUserInput | Prisma.ChannelUsersUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: Prisma.ChannelUsersUpdateManyWithWhereWithoutUserInput | Prisma.ChannelUsersUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: Prisma.ChannelUsersScalarWhereInput | Prisma.ChannelUsersScalarWhereInput[];
};

export type ChannelUsersCreateWithoutChannelInput = {
    createdAt?: Date | string;
    user: Prisma.UserCreateNestedOneWithoutChannelsInput;
};

export type ChannelUsersUncheckedCreateWithoutChannelInput = {
    userId: number;
    createdAt?: Date | string;
};

export type ChannelUsersCreateOrConnectWithoutChannelInput = {
    where: Prisma.ChannelUsersWhereUniqueInput;
    create: Prisma.XOR<Prisma.ChannelUsersCreateWithoutChannelInput, Prisma.ChannelUsersUncheckedCreateWithoutChannelInput>;
};

export type ChannelUsersCreateManyChannelInputEnvelope = {
    data: Prisma.ChannelUsersCreateManyChannelInput | Prisma.ChannelUsersCreateManyChannelInput[];
    skipDuplicates?: boolean;
};

export type ChannelUsersUpsertWithWhereUniqueWithoutChannelInput = {
    where: Prisma.ChannelUsersWhereUniqueInput;
    update: Prisma.XOR<Prisma.ChannelUsersUpdateWithoutChannelInput, Prisma.ChannelUsersUncheckedUpdateWithoutChannelInput>;
    create: Prisma.XOR<Prisma.ChannelUsersCreateWithoutChannelInput, Prisma.ChannelUsersUncheckedCreateWithoutChannelInput>;
};

export type ChannelUsersUpdateWithWhereUniqueWithoutChannelInput = {
    where: Prisma.ChannelUsersWhereUniqueInput;
    data: Prisma.XOR<Prisma.ChannelUsersUpdateWithoutChannelInput, Prisma.ChannelUsersUncheckedUpdateWithoutChannelInput>;
};

export type ChannelUsersUpdateManyWithWhereWithoutChannelInput = {
    where: Prisma.ChannelUsersScalarWhereInput;
    data: Prisma.XOR<Prisma.ChannelUsersUpdateManyMutationInput, Prisma.ChannelUsersUncheckedUpdateManyWithoutChannelInput>;
};

export type ChannelUsersScalarWhereInput = {
    AND?: Prisma.ChannelUsersScalarWhereInput | Prisma.ChannelUsersScalarWhereInput[];
    OR?: Prisma.ChannelUsersScalarWhereInput[];
    NOT?: Prisma.ChannelUsersScalarWhereInput | Prisma.ChannelUsersScalarWhereInput[];
    channelId?: Prisma.IntFilter<'ChannelUsers'> | number;
    userId?: Prisma.IntFilter<'ChannelUsers'> | number;
    createdAt?: Prisma.DateTimeFilter<'ChannelUsers'> | Date | string;
};

export type ChannelUsersCreateWithoutUserInput = {
    createdAt?: Date | string;
    channel: Prisma.ChannelCreateNestedOneWithoutUsersInput;
};

export type ChannelUsersUncheckedCreateWithoutUserInput = {
    channelId: number;
    createdAt?: Date | string;
};

export type ChannelUsersCreateOrConnectWithoutUserInput = {
    where: Prisma.ChannelUsersWhereUniqueInput;
    create: Prisma.XOR<Prisma.ChannelUsersCreateWithoutUserInput, Prisma.ChannelUsersUncheckedCreateWithoutUserInput>;
};

export type ChannelUsersCreateManyUserInputEnvelope = {
    data: Prisma.ChannelUsersCreateManyUserInput | Prisma.ChannelUsersCreateManyUserInput[];
    skipDuplicates?: boolean;
};

export type ChannelUsersUpsertWithWhereUniqueWithoutUserInput = {
    where: Prisma.ChannelUsersWhereUniqueInput;
    update: Prisma.XOR<Prisma.ChannelUsersUpdateWithoutUserInput, Prisma.ChannelUsersUncheckedUpdateWithoutUserInput>;
    create: Prisma.XOR<Prisma.ChannelUsersCreateWithoutUserInput, Prisma.ChannelUsersUncheckedCreateWithoutUserInput>;
};

export type ChannelUsersUpdateWithWhereUniqueWithoutUserInput = {
    where: Prisma.ChannelUsersWhereUniqueInput;
    data: Prisma.XOR<Prisma.ChannelUsersUpdateWithoutUserInput, Prisma.ChannelUsersUncheckedUpdateWithoutUserInput>;
};

export type ChannelUsersUpdateManyWithWhereWithoutUserInput = {
    where: Prisma.ChannelUsersScalarWhereInput;
    data: Prisma.XOR<Prisma.ChannelUsersUpdateManyMutationInput, Prisma.ChannelUsersUncheckedUpdateManyWithoutUserInput>;
};

export type ChannelUsersCreateManyChannelInput = {
    userId: number;
    createdAt?: Date | string;
};

export type ChannelUsersUpdateWithoutChannelInput = {
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    user?: Prisma.UserUpdateOneRequiredWithoutChannelsNestedInput;
};

export type ChannelUsersUncheckedUpdateWithoutChannelInput = {
    userId?: Prisma.IntFieldUpdateOperationsInput | number;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ChannelUsersUncheckedUpdateManyWithoutChannelInput = {
    userId?: Prisma.IntFieldUpdateOperationsInput | number;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ChannelUsersCreateManyUserInput = {
    channelId: number;
    createdAt?: Date | string;
};

export type ChannelUsersUpdateWithoutUserInput = {
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    channel?: Prisma.ChannelUpdateOneRequiredWithoutUsersNestedInput;
};

export type ChannelUsersUncheckedUpdateWithoutUserInput = {
    channelId?: Prisma.IntFieldUpdateOperationsInput | number;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ChannelUsersUncheckedUpdateManyWithoutUserInput = {
    channelId?: Prisma.IntFieldUpdateOperationsInput | number;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ChannelUsersSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
    runtime.Types.Extensions.GetSelect<
        {
            channelId?: boolean;
            userId?: boolean;
            createdAt?: boolean;
            channel?: boolean | Prisma.ChannelDefaultArgs<ExtArgs>;
            user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
        },
        ExtArgs['result']['channelUsers']
    >;

export type ChannelUsersSelectCreateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
    {
        channelId?: boolean;
        userId?: boolean;
        createdAt?: boolean;
        channel?: boolean | Prisma.ChannelDefaultArgs<ExtArgs>;
        user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['channelUsers']
>;

export type ChannelUsersSelectUpdateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
    {
        channelId?: boolean;
        userId?: boolean;
        createdAt?: boolean;
        channel?: boolean | Prisma.ChannelDefaultArgs<ExtArgs>;
        user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['channelUsers']
>;

export type ChannelUsersSelectScalar = {
    channelId?: boolean;
    userId?: boolean;
    createdAt?: boolean;
};

export type ChannelUsersOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
    runtime.Types.Extensions.GetOmit<'channelId' | 'userId' | 'createdAt', ExtArgs['result']['channelUsers']>;
export type ChannelUsersInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    channel?: boolean | Prisma.ChannelDefaultArgs<ExtArgs>;
    user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};
export type ChannelUsersIncludeCreateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    channel?: boolean | Prisma.ChannelDefaultArgs<ExtArgs>;
    user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};
export type ChannelUsersIncludeUpdateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    channel?: boolean | Prisma.ChannelDefaultArgs<ExtArgs>;
    user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};

export type $ChannelUsersPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: 'ChannelUsers';
    objects: {
        /**
         * Ï±ÑÎÑê
         */
        channel: Prisma.$ChannelPayload<ExtArgs>;
        /**
         * ÏÇ¨Ïö©Ïûê
         */
        user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<
        {
            /**
             * Ï±ÑÎÑê ÏïÑÏù¥Îîî
             */
            channelId: number;
            /**
             * ÏÇ¨Ïö©Ïûê ÏïÑÏù¥Îîî
             */
            userId: number;
            /**
             * ÏÉùÏÑ±Ïùº
             */
            createdAt: Date;
        },
        ExtArgs['result']['channelUsers']
    >;
    composites: {};
};

export type ChannelUsersGetPayload<S extends boolean | null | undefined | ChannelUsersDefaultArgs> = runtime.Types.Result.GetResult<
    Prisma.$ChannelUsersPayload,
    S
>;

export type ChannelUsersCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<
    ChannelUsersFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
> & {
    select?: ChannelUsersCountAggregateInputType | true;
};

export interface ChannelUsersDelegate<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
    GlobalOmitOptions = {},
> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChannelUsers']; meta: { name: 'ChannelUsers' } };
    /**
     * Find zero or one ChannelUsers that matches the filter.
     * @param {ChannelUsersFindUniqueArgs} args - Arguments to find a ChannelUsers
     * @example
     * // Get one ChannelUsers
     * const channelUsers = await prisma.channelUsers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelUsersFindUniqueArgs>(
        args: Prisma.SelectSubset<T, ChannelUsersFindUniqueArgs<ExtArgs>>,
    ): Prisma.Prisma__ChannelUsersClient<
        runtime.Types.Result.GetResult<Prisma.$ChannelUsersPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
        null,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find one ChannelUsers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChannelUsersFindUniqueOrThrowArgs} args - Arguments to find a ChannelUsers
     * @example
     * // Get one ChannelUsers
     * const channelUsers = await prisma.channelUsers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelUsersFindUniqueOrThrowArgs>(
        args: Prisma.SelectSubset<T, ChannelUsersFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma.Prisma__ChannelUsersClient<
        runtime.Types.Result.GetResult<Prisma.$ChannelUsersPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find the first ChannelUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUsersFindFirstArgs} args - Arguments to find a ChannelUsers
     * @example
     * // Get one ChannelUsers
     * const channelUsers = await prisma.channelUsers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelUsersFindFirstArgs>(
        args?: Prisma.SelectSubset<T, ChannelUsersFindFirstArgs<ExtArgs>>,
    ): Prisma.Prisma__ChannelUsersClient<
        runtime.Types.Result.GetResult<Prisma.$ChannelUsersPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
        null,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find the first ChannelUsers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUsersFindFirstOrThrowArgs} args - Arguments to find a ChannelUsers
     * @example
     * // Get one ChannelUsers
     * const channelUsers = await prisma.channelUsers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelUsersFindFirstOrThrowArgs>(
        args?: Prisma.SelectSubset<T, ChannelUsersFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma.Prisma__ChannelUsersClient<
        runtime.Types.Result.GetResult<Prisma.$ChannelUsersPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find zero or more ChannelUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChannelUsers
     * const channelUsers = await prisma.channelUsers.findMany()
     *
     * // Get first 10 ChannelUsers
     * const channelUsers = await prisma.channelUsers.findMany({ take: 10 })
     *
     * // Only select the `channelId`
     * const channelUsersWithChannelIdOnly = await prisma.channelUsers.findMany({ select: { channelId: true } })
     *
     */
    findMany<T extends ChannelUsersFindManyArgs>(
        args?: Prisma.SelectSubset<T, ChannelUsersFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ChannelUsersPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>;

    /**
     * Create a ChannelUsers.
     * @param {ChannelUsersCreateArgs} args - Arguments to create a ChannelUsers.
     * @example
     * // Create one ChannelUsers
     * const ChannelUsers = await prisma.channelUsers.create({
     *   data: {
     *     // ... data to create a ChannelUsers
     *   }
     * })
     *
     */
    create<T extends ChannelUsersCreateArgs>(
        args: Prisma.SelectSubset<T, ChannelUsersCreateArgs<ExtArgs>>,
    ): Prisma.Prisma__ChannelUsersClient<
        runtime.Types.Result.GetResult<Prisma.$ChannelUsersPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Create many ChannelUsers.
     * @param {ChannelUsersCreateManyArgs} args - Arguments to create many ChannelUsers.
     * @example
     * // Create many ChannelUsers
     * const channelUsers = await prisma.channelUsers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ChannelUsersCreateManyArgs>(
        args?: Prisma.SelectSubset<T, ChannelUsersCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Create many ChannelUsers and returns the data saved in the modules.database.
     * @param {ChannelUsersCreateManyAndReturnArgs} args - Arguments to create many ChannelUsers.
     * @example
     * // Create many ChannelUsers
     * const channelUsers = await prisma.channelUsers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ChannelUsers and only return the `channelId`
     * const channelUsersWithChannelIdOnly = await prisma.channelUsers.createManyAndReturn({
     *   select: { channelId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ChannelUsersCreateManyAndReturnArgs>(
        args?: Prisma.SelectSubset<T, ChannelUsersCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<Prisma.$ChannelUsersPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Delete a ChannelUsers.
     * @param {ChannelUsersDeleteArgs} args - Arguments to delete one ChannelUsers.
     * @example
     * // Delete one ChannelUsers
     * const ChannelUsers = await prisma.channelUsers.delete({
     *   where: {
     *     // ... filter to delete one ChannelUsers
     *   }
     * })
     *
     */
    delete<T extends ChannelUsersDeleteArgs>(
        args: Prisma.SelectSubset<T, ChannelUsersDeleteArgs<ExtArgs>>,
    ): Prisma.Prisma__ChannelUsersClient<
        runtime.Types.Result.GetResult<Prisma.$ChannelUsersPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Update one ChannelUsers.
     * @param {ChannelUsersUpdateArgs} args - Arguments to update one ChannelUsers.
     * @example
     * // Update one ChannelUsers
     * const channelUsers = await prisma.channelUsers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ChannelUsersUpdateArgs>(
        args: Prisma.SelectSubset<T, ChannelUsersUpdateArgs<ExtArgs>>,
    ): Prisma.Prisma__ChannelUsersClient<
        runtime.Types.Result.GetResult<Prisma.$ChannelUsersPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Delete zero or more ChannelUsers.
     * @param {ChannelUsersDeleteManyArgs} args - Arguments to filter ChannelUsers to delete.
     * @example
     * // Delete a few ChannelUsers
     * const { count } = await prisma.channelUsers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ChannelUsersDeleteManyArgs>(
        args?: Prisma.SelectSubset<T, ChannelUsersDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Update zero or more ChannelUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChannelUsers
     * const channelUsers = await prisma.channelUsers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ChannelUsersUpdateManyArgs>(
        args: Prisma.SelectSubset<T, ChannelUsersUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Update zero or more ChannelUsers and returns the data updated in the modules.database.
     * @param {ChannelUsersUpdateManyAndReturnArgs} args - Arguments to update many ChannelUsers.
     * @example
     * // Update many ChannelUsers
     * const channelUsers = await prisma.channelUsers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ChannelUsers and only return the `channelId`
     * const channelUsersWithChannelIdOnly = await prisma.channelUsers.updateManyAndReturn({
     *   select: { channelId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ChannelUsersUpdateManyAndReturnArgs>(
        args: Prisma.SelectSubset<T, ChannelUsersUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<Prisma.$ChannelUsersPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Create or update one ChannelUsers.
     * @param {ChannelUsersUpsertArgs} args - Arguments to update or create a ChannelUsers.
     * @example
     * // Update or create a ChannelUsers
     * const channelUsers = await prisma.channelUsers.upsert({
     *   create: {
     *     // ... data to create a ChannelUsers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChannelUsers we want to update
     *   }
     * })
     */
    upsert<T extends ChannelUsersUpsertArgs>(
        args: Prisma.SelectSubset<T, ChannelUsersUpsertArgs<ExtArgs>>,
    ): Prisma.Prisma__ChannelUsersClient<
        runtime.Types.Result.GetResult<Prisma.$ChannelUsersPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Count the number of ChannelUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUsersCountArgs} args - Arguments to filter ChannelUsers to count.
     * @example
     * // Count the number of ChannelUsers
     * const count = await prisma.channelUsers.count({
     *   where: {
     *     // ... the filter for the ChannelUsers we want to count
     *   }
     * })
     **/
    count<T extends ChannelUsersCountArgs>(
        args?: Prisma.Subset<T, ChannelUsersCountArgs>,
    ): Prisma.PrismaPromise<
        T extends runtime.Types.Utils.Record<'select', any>
            ? T['select'] extends true
                ? number
                : Prisma.GetScalarType<T['select'], ChannelUsersCountAggregateOutputType>
            : number
    >;

    /**
     * Allows you to perform aggregations operations on a ChannelUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.modules.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ChannelUsersAggregateArgs>(
        args: Prisma.Subset<T, ChannelUsersAggregateArgs>,
    ): Prisma.PrismaPromise<GetChannelUsersAggregateType<T>>;

    /**
     * Group by ChannelUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.modules.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
        T extends ChannelUsersGroupByArgs,
        HasSelectOrTake extends Prisma.Or<Prisma.Extends<'skip', Prisma.Keys<T>>, Prisma.Extends<'take', Prisma.Keys<T>>>,
        OrderByArg extends Prisma.True extends HasSelectOrTake
            ? { orderBy: ChannelUsersGroupByArgs['orderBy'] }
            : { orderBy?: ChannelUsersGroupByArgs['orderBy'] },
        OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
        ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
        ByValid extends Prisma.Has<ByFields, OrderFields>,
        HavingFields extends Prisma.GetHavingFields<T['having']>,
        HavingValid extends Prisma.Has<ByFields, HavingFields>,
        ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
        InputErrors extends ByEmpty extends Prisma.True
            ? `Error: "by" must not be empty.`
            : HavingValid extends Prisma.False
              ? {
                    [P in HavingFields]: P extends ByFields
                        ? never
                        : P extends string
                          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                          : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Prisma.Keys<T>
                ? 'orderBy' extends Prisma.Keys<T>
                    ? ByValid extends Prisma.True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                    : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Prisma.Keys<T>
                  ? 'orderBy' extends Prisma.Keys<T>
                      ? ByValid extends Prisma.True
                          ? {}
                          : {
                                [P in OrderFields]: P extends ByFields
                                    ? never
                                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                            }[OrderFields]
                      : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends Prisma.True
                    ? {}
                    : {
                          [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
    >(
        args: Prisma.SubsetIntersection<T, ChannelUsersGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetChannelUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ChannelUsers model
     */
    readonly fields: ChannelUsersFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for ChannelUsers.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ChannelUsersClient<
    T,
    Null = never,
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
    GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    channel<T extends Prisma.ChannelDefaultArgs<ExtArgs> = {}>(
        args?: Prisma.Subset<T, Prisma.ChannelDefaultArgs<ExtArgs>>,
    ): Prisma.Prisma__ChannelClient<
        runtime.Types.Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
        Null,
        ExtArgs,
        GlobalOmitOptions
    >;
    user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(
        args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>,
    ): Prisma.Prisma__UserClient<
        runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
        Null,
        ExtArgs,
        GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
        onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the ChannelUsers model
 */
export interface ChannelUsersFieldRefs {
    readonly channelId: Prisma.FieldRef<'ChannelUsers', 'Int'>;
    readonly userId: Prisma.FieldRef<'ChannelUsers', 'Int'>;
    readonly createdAt: Prisma.FieldRef<'ChannelUsers', 'DateTime'>;
}

// Custom InputTypes
/**
 * ChannelUsers findUnique
 */
export type ChannelUsersFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelUsers
     */
    select?: Prisma.ChannelUsersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ChannelUsers
     */
    omit?: Prisma.ChannelUsersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ChannelUsersInclude<ExtArgs> | null;
    /**
     * Filter, which ChannelUsers to fetch.
     */
    where: Prisma.ChannelUsersWhereUniqueInput;
};

/**
 * ChannelUsers findUniqueOrThrow
 */
export type ChannelUsersFindUniqueOrThrowArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ChannelUsers
     */
    select?: Prisma.ChannelUsersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ChannelUsers
     */
    omit?: Prisma.ChannelUsersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ChannelUsersInclude<ExtArgs> | null;
    /**
     * Filter, which ChannelUsers to fetch.
     */
    where: Prisma.ChannelUsersWhereUniqueInput;
};

/**
 * ChannelUsers findFirst
 */
export type ChannelUsersFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelUsers
     */
    select?: Prisma.ChannelUsersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ChannelUsers
     */
    omit?: Prisma.ChannelUsersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ChannelUsersInclude<ExtArgs> | null;
    /**
     * Filter, which ChannelUsers to fetch.
     */
    where?: Prisma.ChannelUsersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ChannelUsers to fetch.
     */
    orderBy?: Prisma.ChannelUsersOrderByWithRelationInput | Prisma.ChannelUsersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ChannelUsers.
     */
    cursor?: Prisma.ChannelUsersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` ChannelUsers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ChannelUsers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ChannelUsers.
     */
    distinct?: Prisma.ChannelUsersScalarFieldEnum | Prisma.ChannelUsersScalarFieldEnum[];
};

/**
 * ChannelUsers findFirstOrThrow
 */
export type ChannelUsersFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
    {
        /**
         * Select specific fields to fetch from the ChannelUsers
         */
        select?: Prisma.ChannelUsersSelect<ExtArgs> | null;
        /**
         * Omit specific fields from the ChannelUsers
         */
        omit?: Prisma.ChannelUsersOmit<ExtArgs> | null;
        /**
         * Choose, which related nodes to fetch as well
         */
        include?: Prisma.ChannelUsersInclude<ExtArgs> | null;
        /**
         * Filter, which ChannelUsers to fetch.
         */
        where?: Prisma.ChannelUsersWhereInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of ChannelUsers to fetch.
         */
        orderBy?: Prisma.ChannelUsersOrderByWithRelationInput | Prisma.ChannelUsersOrderByWithRelationInput[];
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for ChannelUsers.
         */
        cursor?: Prisma.ChannelUsersWhereUniqueInput;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `¬±n` ChannelUsers from the position of the cursor.
         */
        take?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` ChannelUsers.
         */
        skip?: number;
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of ChannelUsers.
         */
        distinct?: Prisma.ChannelUsersScalarFieldEnum | Prisma.ChannelUsersScalarFieldEnum[];
    };

/**
 * ChannelUsers findMany
 */
export type ChannelUsersFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelUsers
     */
    select?: Prisma.ChannelUsersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ChannelUsers
     */
    omit?: Prisma.ChannelUsersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ChannelUsersInclude<ExtArgs> | null;
    /**
     * Filter, which ChannelUsers to fetch.
     */
    where?: Prisma.ChannelUsersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ChannelUsers to fetch.
     */
    orderBy?: Prisma.ChannelUsersOrderByWithRelationInput | Prisma.ChannelUsersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ChannelUsers.
     */
    cursor?: Prisma.ChannelUsersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` ChannelUsers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ChannelUsers.
     */
    skip?: number;
    distinct?: Prisma.ChannelUsersScalarFieldEnum | Prisma.ChannelUsersScalarFieldEnum[];
};

/**
 * ChannelUsers create
 */
export type ChannelUsersCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelUsers
     */
    select?: Prisma.ChannelUsersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ChannelUsers
     */
    omit?: Prisma.ChannelUsersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ChannelUsersInclude<ExtArgs> | null;
    /**
     * The data needed to create a ChannelUsers.
     */
    data: Prisma.XOR<Prisma.ChannelUsersCreateInput, Prisma.ChannelUsersUncheckedCreateInput>;
};

/**
 * ChannelUsers createMany
 */
export type ChannelUsersCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChannelUsers.
     */
    data: Prisma.ChannelUsersCreateManyInput | Prisma.ChannelUsersCreateManyInput[];
    skipDuplicates?: boolean;
};

/**
 * ChannelUsers createManyAndReturn
 */
export type ChannelUsersCreateManyAndReturnArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ChannelUsers
     */
    select?: Prisma.ChannelUsersSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ChannelUsers
     */
    omit?: Prisma.ChannelUsersOmit<ExtArgs> | null;
    /**
     * The data used to create many ChannelUsers.
     */
    data: Prisma.ChannelUsersCreateManyInput | Prisma.ChannelUsersCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ChannelUsersIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * ChannelUsers update
 */
export type ChannelUsersUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelUsers
     */
    select?: Prisma.ChannelUsersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ChannelUsers
     */
    omit?: Prisma.ChannelUsersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ChannelUsersInclude<ExtArgs> | null;
    /**
     * The data needed to update a ChannelUsers.
     */
    data: Prisma.XOR<Prisma.ChannelUsersUpdateInput, Prisma.ChannelUsersUncheckedUpdateInput>;
    /**
     * Choose, which ChannelUsers to update.
     */
    where: Prisma.ChannelUsersWhereUniqueInput;
};

/**
 * ChannelUsers updateMany
 */
export type ChannelUsersUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update ChannelUsers.
     */
    data: Prisma.XOR<Prisma.ChannelUsersUpdateManyMutationInput, Prisma.ChannelUsersUncheckedUpdateManyInput>;
    /**
     * Filter which ChannelUsers to update
     */
    where?: Prisma.ChannelUsersWhereInput;
    /**
     * Limit how many ChannelUsers to update.
     */
    limit?: number;
};

/**
 * ChannelUsers updateManyAndReturn
 */
export type ChannelUsersUpdateManyAndReturnArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the ChannelUsers
     */
    select?: Prisma.ChannelUsersSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ChannelUsers
     */
    omit?: Prisma.ChannelUsersOmit<ExtArgs> | null;
    /**
     * The data used to update ChannelUsers.
     */
    data: Prisma.XOR<Prisma.ChannelUsersUpdateManyMutationInput, Prisma.ChannelUsersUncheckedUpdateManyInput>;
    /**
     * Filter which ChannelUsers to update
     */
    where?: Prisma.ChannelUsersWhereInput;
    /**
     * Limit how many ChannelUsers to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ChannelUsersIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * ChannelUsers upsert
 */
export type ChannelUsersUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelUsers
     */
    select?: Prisma.ChannelUsersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ChannelUsers
     */
    omit?: Prisma.ChannelUsersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ChannelUsersInclude<ExtArgs> | null;
    /**
     * The filter to search for the ChannelUsers to update in case it exists.
     */
    where: Prisma.ChannelUsersWhereUniqueInput;
    /**
     * In case the ChannelUsers found by the `where` argument doesn't exist, create a new ChannelUsers with this data.
     */
    create: Prisma.XOR<Prisma.ChannelUsersCreateInput, Prisma.ChannelUsersUncheckedCreateInput>;
    /**
     * In case the ChannelUsers was found with the provided `where` argument, update it with this data.
     */
    update: Prisma.XOR<Prisma.ChannelUsersUpdateInput, Prisma.ChannelUsersUncheckedUpdateInput>;
};

/**
 * ChannelUsers delete
 */
export type ChannelUsersDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelUsers
     */
    select?: Prisma.ChannelUsersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ChannelUsers
     */
    omit?: Prisma.ChannelUsersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ChannelUsersInclude<ExtArgs> | null;
    /**
     * Filter which ChannelUsers to delete.
     */
    where: Prisma.ChannelUsersWhereUniqueInput;
};

/**
 * ChannelUsers deleteMany
 */
export type ChannelUsersDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelUsers to delete
     */
    where?: Prisma.ChannelUsersWhereInput;
    /**
     * Limit how many ChannelUsers to delete.
     */
    limit?: number;
};

/**
 * ChannelUsers without action
 */
export type ChannelUsersDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelUsers
     */
    select?: Prisma.ChannelUsersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ChannelUsers
     */
    omit?: Prisma.ChannelUsersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.ChannelUsersInclude<ExtArgs> | null;
};
